//
// Created by etien on 02/02/2022.
//

#include "ExploitPosition.h"
#include "src/InputNode.h"

MoveTowardPositionOnce::MoveTowardPositionOnce(int mShipId, hlt::Position mpPoi) {

    // If poi has been reached once, disable this node
    AddChild(bt::Create<bt::InputNode>(
            [=](hlt::Game &rGame) -> bool {
//                hlt::log::log(" >>> SHIPID = " + std::to_string(mShipId));
                return !mReached;
            }));


    // Move toward dropoff location
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi));

    // When location origin reached, turn off this node
    AddChild(bt::Create<bt::InputNode>(
            [=](hlt::Game &rGame) -> bool {
                mReached = true;
                return true;
            }));
}

MoveToBestCell::MoveToBestCell(int mShipId) : mShipID(mShipId) {

    // Move to neighbour cell if it is worth it
    auto getBestCell = bt::Create<BehaviourTree::InputNode>(
            [this](hlt::Game &rGame) {

                const auto shipPos = rGame.me->get_ship(mShipID)->position;

                // Halite on current cell
                int currentHalite = rGame.game_map->at(shipPos)->halite;

                int moveCost = currentHalite * 1./hlt::constants::MOVE_COST_RATIO;
                int currentHaliteGain = currentHalite * 1./hlt::constants::EXTRACT_RATIO;

                int bestHalite = 0;
                hlt::Position nextPos = shipPos;

                // Awful code copy/paste, put a for loop instead
                // Check each direction and get the best

                auto hn = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::NORTH));
                if(hn->halite > bestHalite && !hn->is_occupied()) {
                    bestHalite = hn->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::NORTH);
                }

                auto hs = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::SOUTH));
                if(hs->halite > bestHalite && !hs->is_occupied()) {
                    bestHalite = hs->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::SOUTH);
                }

                auto hw = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::WEST));
                if(hw->halite > bestHalite && !hw->is_occupied()) {
                    bestHalite = hw->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::WEST);
                }

                auto he = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::EAST));
                if(he->halite > bestHalite && !he->is_occupied()) {
                    bestHalite = he->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::EAST);
                }

                // No position has been chosen
                if(nextPos == shipPos) {
                    // Random to remove
                    mTargetCell = shipPos.directional_offset(hlt::ALL_CARDINALS[rand()%4]);
                    return true;
                }

                if((bestHalite * (1./hlt::constants::EXTRACT_RATIO)) - moveCost >= currentHaliteGain) {
                    mTargetCell = nextPos;
                    return true;
                }

                return false;

            }
    );
    AddChild(getBestCell);

    // Move to the selected cell
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPositionPtr>(mShipId, &mTargetCell));

}

GatherHalite::GatherHalite(int mShipId) {

    // Distance at which a dropoff we be used to depositing halite
    constexpr float DROPOFF_NEARBY_DISTANCE = 15;

    // Is in depot State
    // Check if dropoff nearby, if not become one else goto
    {

        auto andNode = bt::Create<bt::AndNode>();
        {

            // if we are in this state
            auto isInDropoffMode = bt::Create<bt::InputNode>(
                    [=](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        // Set the right state
                        if (ship->halite >= (rGame.turn_number < 300 ? 600 : 1000) ) mState = GoToDropoff;
                        return mState == GoToDropoff;

                    });
            andNode->AddChild(isInDropoffMode);


            // Find the closest dropoff
            auto findClosestDropoff = bt::Create<bt::InputNode>(
                    [mShipId, this, DROPOFF_NEARBY_DISTANCE](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        mClosestDropoff = rGame.me->shipyard->position;
                        int dist = rGame.game_map->calculate_distance(mClosestDropoff, ship->position);

                        for(const auto& dropoffPair : rGame.me->dropoffs) {
                            const auto& dropoff = dropoffPair.second;


                            int subdist = rGame.game_map->calculate_distance(dropoff->position, ship->position);
                            if(subdist < dist) {
                                dist = subdist;
                                mClosestDropoff = dropoff->position;
                            }
                        }

                        bool nearby = dist < DROPOFF_NEARBY_DISTANCE;
                        if(!nearby) {

                            // Check if we have enough halite
                            if(rGame.me->halite + ship->halite + rGame.game_map->at(ship->position)->halite >= hlt::constants::DROPOFF_COST) {
                                mState = BecomeDropoff;
                            }
                            else {
                                // Not enough money
                                return true;
                            }
                        }

                        // Check if the closest dropoff is nearby
                        return nearby;
                    });
            andNode->AddChild(findClosestDropoff);


            // Go to the dropoff
            auto depot = bt::Create<bt::InputNode>(
                    [mShipId, this](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        // If the ship arrived to destination
                        if (ship->position == mClosestDropoff) {
                            mState = Gather;
                            return false;
                        }

                        // If there is already a ship on the dropoff
                        if (rGame.game_map->at(mClosestDropoff)->is_occupied()) {
                            return false;
                        }

                        // The ship slowly goes to the dropoff, Next node ->>>
                        return true;

                    });
            andNode->AddChild(depot);

            // Move toward the dropoff
            andNode->AddChild(bt::Create<BehaviourTree::ActionNodes::MoveTowardPositionPtr>(mShipId, &mClosestDropoff));

        }
        AddChild(andNode);

    }

    // Is in BecomeDropoff state
    {
        auto andNode = bt::Create<bt::AndNode>();
        {
            // if we are in this state
            auto isInBecomeDropoffMode = bt::Create<bt::InputNode>(
                    [=](hlt::Game &rGame) {
                        return mState == BecomeDropoff;
                    });
            andNode->AddChild(isInBecomeDropoffMode);

            // If it's not the end of the game
            auto endOfGame = bt::Create<bt::InputNode>(
                    [=](hlt::Game& rGame) {
                        return rGame.turn_number < 400;
                    });
            andNode->AddChild(endOfGame);

            // Become a dropoff
            andNode->AddChild(bt::Create<bt::ActionNodes::MakeDropoff>(mShipId));
        }
        AddChild(andNode);
    }

    // Is in gather state
    AddChild(bt::Create<MoveToBestCell>(mShipId));
    AddChild(bt::Create<bt::ActionNodes::StayStill>(mShipId));
}

ExploitPosition::ExploitPosition(int mShipId, hlt::Position position)  : mPositionToExploit(position) {
    AddChild(bt::Create<MoveTowardPositionOnce>(mShipId, position));
    AddChild(bt::Create<GatherHalite>(mShipId));

    // Find a new target
    auto newDestination = bt::Create<BehaviourTree::InputNode>(
            [this, mShipId](hlt::Game &rGame) -> bool {

                ReplaceChild(0, bt::Create<MoveTowardPositionOnce>(mShipId, mPositionToExploit));

                return true;
            });
    AddChild(newDestination);
}

