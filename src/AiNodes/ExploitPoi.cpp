//
// Created by etien on 02/02/2022.
//

#include "ExploitPoi.h"
#include "src/InputNode.h"


inline hlt::Halite TwoTurnEarnings(hlt::Halite halite) {
    auto firstTurn = halite / hlt::constants::EXTRACT_RATIO;
    auto secondTurn = (halite - firstTurn) / hlt::constants::EXTRACT_RATIO;
    return firstTurn + secondTurn;
}


DropoffPoi::DropoffPoi(int mShipId, PointOfInterest *mpPoi) : mShipID(mShipId), mpPoi(mpPoi) {

    // POI has dropoff
    {
        auto inverter = bt::Create<bt::Inverter>();
        {
            auto poiHasDropOff = bt::Create<bt::InputNode>(
                    [=](hlt::Game& rGame){
                        auto cell = rGame.game_map->at(mpPoi->mOrigin);
                        return cell->has_structure() && cell->structure->owner == rGame.me->id;
                    });

            inverter->SetChild(poiHasDropOff);
        }
        AddChild(inverter);
    }

    // Has enough Halite
    {
        auto hasEnoughHalite = bt::Create<bt::InputNode>(
                [=](hlt::Game& rGame){
                    auto ship = rGame.me->get_ship(mShipID);
                    hlt::Halite shipCargo = ship->halite;
                    hlt::Halite inTheSea = rGame.game_map->at(ship)->halite;
                    return rGame.me->halite + shipCargo + inTheSea >= hlt::constants::DROPOFF_COST
                ;});

        AddChild(hasEnoughHalite);
    }

    // Move toward dropoff location
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi->mOrigin));

    // Become dropoff
    AddChild(bt::Create<bt::ActionNodes::MakeDropoff>(mShipId));

}

GoToPoi::GoToPoi(int mShipId, PointOfInterest *mpPoi) : mShipID(mShipId), mpPoi(mpPoi) {

    // Is in POI
    {
        auto inverter = bt::Create<bt::Inverter>();
        {
            auto isInPoi = bt::Create<bt::InputNode>(
                    [=](hlt::Game& rGame){
                        auto ship = rGame.me->get_ship(mShipId);
                        return mpPoi->IsInside(ship->position);
                    });

            inverter->SetChild(isInPoi);
        }
        AddChild(inverter);
    }

    // Move toward dropoff location
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi->mOrigin));

}

hlt::EntityId GoToPoi::GetShipId() const {
    return mShipID;
}

PointOfInterest *GoToPoi::GetPoi() const {
    return mpPoi;
}

MoveToNeighbourCell::MoveToNeighbourCell(int mShipId) : mShipID(mShipId) {

    // Worth it ?
    {
        auto worthIt = bt::Create<bt::InputNode>(
                [mShipId, this](hlt::Game& rGame){

                    auto ship = rGame.me->get_ship(mShipId);

                    if(rGame.game_map->at(ship)->halite > 100) return false;

                    hlt::Halite bestDirHalite = 0;
                    hlt::Direction bestDir = hlt::Direction::STILL;

                    for(const hlt::Direction& dir : hlt::ALL_CARDINALS) {
                        hlt::Halite dirHalite = rGame.game_map->at(ship->position.directional_offset(dir))->halite;
                        if(dirHalite > bestDirHalite) {
                            bestDirHalite = dirHalite;
                            bestDir = dir;
                        }
                    }

                    mTargetNeighbourCell = ship->position.directional_offset(bestDir);
                    return true;
                });

        AddChild(worthIt);
    }

    AddChild(bt::Create<bt::ActionNodes::MoveTowardPositionPtr>(mShipId, &mTargetNeighbourCell));

}

GatherHalite::GatherHalite(int mShipId, PointOfInterest *mpPoi) : mShipID(mShipId), mpPoi(mpPoi) {
    AddChild(bt::Create<MoveToNeighbourCell>(mShipId));
    AddChild(bt::Create<bt::ActionNodes::StayStill>(mShipId));
}


ExploitPoi::ExploitPoi(int mShipId, PointOfInterest *mpPoi) : mShipID(mShipId), mpPoi(mpPoi) {
//    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi->mOrigin));
    AddChild(bt::Create<DropoffPoi>(mShipId, mpPoi));
    AddChild(bt::Create<GatherHalite>(mShipId, mpPoi));
}

