//
// Created by etien on 02/02/2022.
//

#include "ExploitPoi.h"
#include "src/InputNode.h"


inline hlt::Halite TwoTurnEarnings(hlt::Halite halite) {
    auto firstTurn = halite / hlt::constants::EXTRACT_RATIO;
    auto secondTurn = (halite - firstTurn) / hlt::constants::EXTRACT_RATIO;
    return firstTurn + secondTurn;
}


MoveTowardPositionOnce::MoveTowardPositionOnce(int mShipId, hlt::Position mpPoi) : mShipID(mShipId) {

    // If poi has been reached once, disable this node
    AddChild(bt::Create<bt::InputNode>(
            [=](hlt::Game &rGame) -> bool {
                hlt::log::log("===== SHIPID = " + std::to_string(mShipId));
                return !mReached;
            }));


    // Move toward dropoff location
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi));

    // When poi's origin reached, turn off this node
    AddChild(bt::Create<bt::InputNode>(
            [=](hlt::Game &rGame) -> bool {
                mReached = true;
                return true;
            }));
}

GoToPoi::GoToPoi(int mShipId, PointOfInterest *mpPoi) : mShipID(mShipId), mpPoi(mpPoi) {

    // Is in POI
    {
        auto inverter = bt::Create<bt::Inverter>();
        {
            auto isInPoi = bt::Create<bt::InputNode>(
                    [=](hlt::Game &rGame) {
                        auto ship = rGame.me->get_ship(mShipId);
                        return mpPoi->IsInside(ship->position);
                    });

            inverter->SetChild(isInPoi);
        }
        AddChild(inverter);
    }

    // Move toward dropoff location
    AddChild(bt::Create<bt::ActionNodes::MoveTowardPosition>(mShipId, mpPoi->mOrigin));

}

hlt::EntityId GoToPoi::GetShipId() const {
    return mShipID;
}

PointOfInterest *GoToPoi::GetPoi() const {
    return mpPoi;
}

MoveToBestCell::MoveToBestCell(int mShipId) : mShipID(mShipId) {

    // Move to neighbour cell if it contains more halite
    auto getBestCell = bt::Create<BehaviourTree::InputNode>(
            [this](hlt::Game &rGame) {

                const auto shipPos = rGame.me->get_ship(mShipID)->position;

                int currentHalite = rGame.game_map->at(shipPos)->halite;

                int moveCost = currentHalite * 1./hlt::constants::MOVE_COST_RATIO;
                int curretnHaliteGain = currentHalite * 1./hlt::constants::EXTRACT_RATIO;

                int bestHalite = 0;
                hlt::Position nextPos = shipPos;

                auto hn = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::NORTH));
                if(hn->halite > bestHalite && !hn->is_occupied()) {
                    bestHalite = hn->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::NORTH);
                }

                auto hs = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::SOUTH));
                if(hs->halite > bestHalite && !hs->is_occupied()) {
                    bestHalite = hs->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::SOUTH);
                }

                auto hw = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::WEST));
                if(hw->halite > bestHalite && !hw->is_occupied()) {
                    bestHalite = hw->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::WEST);
                }

                auto he = rGame.game_map->at(shipPos.directional_offset(hlt::Direction::EAST));
                if(he->halite > bestHalite && !he->is_occupied()) {
                    bestHalite = he->halite;
                    nextPos = shipPos.directional_offset(hlt::Direction::EAST);
                }

                if(nextPos == shipPos) {
                    mTargetCell = shipPos.directional_offset(hlt::ALL_CARDINALS[rand()%4]);
                    return true;
                }

                if((bestHalite * (1./hlt::constants::EXTRACT_RATIO)) - moveCost >= currentHalite) {
                    mTargetCell = nextPos;
                    return true;
                }

                return false;

            }
    );
    AddChild(getBestCell);

    AddChild(bt::Create<bt::ActionNodes::MoveTowardPositionPtr>(mShipId, &mTargetCell));

}

GatherHalite::GatherHalite(int mShipId) : mShipID(mShipId){

    constexpr float DROPOFF_NEARBY_DISTANCE = 15;

    // Is in depot State
    // Check if dropoff nearby, if not become one else goto
    {

        auto andNode = bt::Create<bt::AndNode>();
        {

            // if we are in this state
            auto isInDropoffMode = bt::Create<bt::InputNode>(
                    [=](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        // Set the right state
                        if (ship->halite >= (rGame.turn_number < 300 ? 600 : 1000) ) mState = GoToDropoff;
                        return mState == GoToDropoff;

                    });
            andNode->AddChild(isInDropoffMode);


            // Find the closest dropoff
            auto findClosestDropoff = bt::Create<bt::InputNode>(
                    [mShipId, this, DROPOFF_NEARBY_DISTANCE](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        mClosestDropoff = rGame.me->shipyard->position;
                        int dist = rGame.game_map->calculate_distance(mClosestDropoff, ship->position);

                        for(const auto& dropoffPair : rGame.me->dropoffs) {
                            const auto& dropoff = dropoffPair.second;


                            int subdist = rGame.game_map->calculate_distance(dropoff->position, ship->position);
                            if(subdist < dist) {
                                dist = subdist;
                                mClosestDropoff = dropoff->position;
                            }
                        }

                        bool nearby = dist < DROPOFF_NEARBY_DISTANCE;
                        if(!nearby) {

                            // Check if we have enough halite
                            if(rGame.me->halite + ship->halite + rGame.game_map->at(ship->position)->halite >= hlt::constants::DROPOFF_COST) {
                                mState = BecomeDropoff;
                            }
                            else {
                                // Not enough money
                                return true;
                            }
                        }

                        // Check if the closest dropoff is nearby
                        return nearby;
                    });
            andNode->AddChild(findClosestDropoff);


            // Go to the dropoff
            auto depot = bt::Create<bt::InputNode>(
                    [mShipId, this](hlt::Game &rGame) {

                        auto ship = rGame.me->get_ship(mShipId);

                        // If the ship arrived to destination
                        if (ship->position == mClosestDropoff) {
                            mState = Gather;
                            return false;
                        }

                        // If there is already a ship on the dropoff
                        if (rGame.game_map->at(mClosestDropoff)->is_occupied()) {
                            return false;
                        }

                        // The ship slowly goes to the dropoff, Next node ->>>
                        return true;

                    });
            andNode->AddChild(depot);

            // Move toward the dropoff
            andNode->AddChild(bt::Create<BehaviourTree::ActionNodes::MoveTowardPositionPtr>(mShipId, &mClosestDropoff));

        }
        AddChild(andNode);

    }

    // Is in BecomeDropoff state
    {
        auto andNode = bt::Create<bt::AndNode>();
        {
            // if we are in this state
            auto isInBecomeDropoffMode = bt::Create<bt::InputNode>(
                    [=](hlt::Game &rGame) {
                        return mState == BecomeDropoff;
                    });
            andNode->AddChild(isInBecomeDropoffMode);

            // If it's not the end of the game
            auto endOfGame = bt::Create<bt::InputNode>(
                    [=](hlt::Game& rGame) {
                        return rGame.turn_number < 400;
                    });
            andNode->AddChild(endOfGame);

            // Become a dropoff
            andNode->AddChild(bt::Create<bt::ActionNodes::MakeDropoff>(mShipId));
        }
        AddChild(andNode);
    }

    // Is in gather state
    AddChild(bt::Create<MoveToBestCell>(mShipId));
    AddChild(bt::Create<bt::ActionNodes::StayStill>(mShipId));
}

ExploitPoi::ExploitPoi(int mShipId, PointOfInterest* mpPoi) {
    //AddChild(bt::Create<MoveTowardPositionOnce>(mShipId, mpPoi));
    //AddChild(bt::Create<GatherHalite>(mShipId));
}

ExploitPosition::ExploitPosition(int mShipId, hlt::Position position)  : mPositionToExploit(position) {
    AddChild(bt::Create<MoveTowardPositionOnce>(mShipId, position));
    AddChild(bt::Create<GatherHalite>(mShipId));

    // Find a new target
    auto newDestination = bt::Create<BehaviourTree::InputNode>(
            [this, mShipId](hlt::Game &rGame) -> bool {

                ReplaceChild(0, bt::Create<MoveTowardPositionOnce>(mShipId, mPositionToExploit));

                return true;
            });
    AddChild(newDestination);
}

